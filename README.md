# Blackjack Project

# Description
The purpose of this project is to develop a functional blackjack game that can run on the console of the Eclipse using the JVM. To accomplish this a few objects needed to be created as a precursor to the development of the logic of the game. The first of these are two enumerators that are used to create the two parts of a playing card; the Suit and the Rank. The Suit enumerator is fairly straightforward. Four constants are created to reflect the 4 types of suits in a deck of cards. A constructor is used to assign string names to each suit. A similar process is used to create the ranks aside from using integers and strings to allow the use of each card's numerical value and string name. After this, the card itself is created. This is accomplished by assigning the suit and rank in the constructor of the card's class. 

The next object class created is the Deck. The enumerators are stored in arrays based on the number of constants each uses. These arrays are iterated through in two for each loops to assign a suit and rank to each newly created card. The deck is also able to be interacted with by another object. This is accomplished through its four methods that return the deck's remaining size, allow cards to be dealt from the deck,  shuffle the deck, and list the entire deck of cards. 

The cards within the deck are dealt into the BlackjackHand object which extends the abstract Hand class. The Hand class has one protected field which is the array list that will be populated by the cards dealt into the hand. The Hand class also has valuable methods in the addCard method which, as the name suggests, allows you to add cards to your hand, and the clearCards method which allows the user to discard the cards in their hand. This allows the array list can be re-populated during the next hand in the game. These classes are not set as abstract because they are universal actions throughout most if not all card games. The method getHandValue however, is set to abstract because hands through differing games will have different values. 

The BlackjackHand class extends the hand class and therefore inherits its array and implements its get hand value method. This method is implemented through a for each loop that adds each card together and stores and returns the sum variable. The BlackjackHand class also has two methods that return booleans to check whether the hand is a blackjack or a bust. These are used during the logic of the game to account for each specific blackjack situation. 

To interact with these blackjack hands is the superclass BlackjackPlayer and its subclass BlackjackDealer. The BlackjackPlayer class has one protected BlackjackHand field. This field is set in the BlackjackPlayer constructor so a BlackjackPlayer is required to be connected to a BlackjackHand. The BlackjackPlayer also has the ability to check their hands value through the method checkHandValue which prints the player's hands value using the getHandValue method in the BlackjackHand class. The BlackjackPlayer also has the ability to show their hand using the showPlayerHand method. This method is used throughout the application to display the players cards. 

The BlackjackDealer class extends the BlackjackPlayer class so it inherits the player class's protected BlackjackHand field, but also has a field of its own; the dealersDeck. The BlackjackHand field is set in the constructor using the super class and the constructor is also used to shuffle the deck. This allows the deck to automatically shuffle any time a dealer object is instantiated. The BlackjackDealer interacts with its deck through a few different methods. First, the dealer can check the amount of cards remaining in the deck using the cardsRemaining method. This is useful for ensuring that the game is ended before encountering an IndexOutOfBounds exception. Second, the dealer interacts with the deck by dealing cards to the player both face up and to themselves with the first card face down and the second card face up. Both of these methods call the dealCard method from the Deck class for their functionality. Finally, the dealer interacts with the deck by through shuffling. As stated, this is done automatically when a dealer is instantiated with its functionality coming through calling the shuffle method in the Deck class. The dealer can also interact with their own cards throughout the game. This is accomplished first through the showOneCard and oneCardValue methods. These two methods are specific for the dealer since the dealer does not reveal the bottom card they are dealt until the players turn is over. Therefore, at the time of dealing they can only show one card and one cards value. The BlackjackDealer class can also show their entire hand, and their entire hands value in the same way the player does. The checkHandValue class is overridden in the dealer class by changing the output to match the dealer. The showDealersHand class could have overridden the player class, but was not solely for ease of use and readability reasons. 

The BlackjackApp class contains the main logic of the game and the main method that runs the entire program. Each time the program is run, a player and a dealer and their respective hands are instantiated. The BlackjackApp class also has three fields that are static to the class and final throughout the class. The RULE_OF_SEVENTEEN field is used in the dealerMechanic method to cause the dealer to stand if their hand ever becomes 17 or greater and less than 21 per the rules of blackjack. The CUT_CARD field is used in the outer while loop throughout the program. This is set to 13 because blackjack games traditionally end when only a quarter of the deck or less is remaining. The final field is the HIGHEST_BLACKJACK_SCORE. This is set to 21 as it is the highest winning score a player can achieve in blackjack. It is used throughout the playerDecision and dealerMechanic class to check to see if a player has bust. It is also used immediately after cards are dealt to ensure no player has a starting hand above 21. As we are only using aces as 11 and not 1/11 in this project, it is necessary to check when the cards are initially dealt that the player or dealer do not have two aces equaling 22. 

The program beings by calling the playGame method through the invoking BlackjackApp object bjapp. This playGame method initializes two booleans isGameContinuing and checkStop which are used to run and end the inner while loop. The inner while loop allows hands to be repeated with the same deck until the deck hits the CUT_CARD amount. After these assignments, is the creation of the first while loop that checks that there are enough cards left to continue on with the game. The nested while loop begins by clearing the player and dealers hands much like what would happen in a Casino. Although this is not necessary the first iteration of this loop, it becomes necessary as the user progresses through the deck. Without these method calls, the values of hands would continue on to the next hand. Next, the dealHands method is called. This logic handles the dealing process unique to blackjack. The player is dealt a card through the showPlayersHand method. This card is visible to both players and that card is subsequently added to the players BlackjackHand array list. The dealer is then dealt a card face down which is accomplished by simply not calling the showDealersHand method. A second card is dealt to the player in the same way as the first, and a second card is dealt to the dealer. However, this time the card is shown using the showOneCard method and the value is displayed using the oneCardValue method. The players hand value is then shown using the checkHandValue method. 

Next as previously stated, the hands are checked to ensure neither hand has two aces equaling 22. If this occurs the loop is broken and resets to the next iteration. If this does not occur, the blackjackCheck method is called. This method is used to ensure that if the player or dealer have a blackjack that the game loop is broken and the next iteration occurs. This is done through a series of three if and else if statements that check for either player having a blackjack or both players having a blackjack. If either of these situations occurs the boolean isGameContinuing is returned as false to the playGame method. In the playGame method this method return is set to the variable checkStop which is used to check a few conditions. First, if the blackjackCheck method returns the isGameContinuing boolean unchanged, then the if and else if statements will not be tested. If it is returned as false the program first checks to see if the amount of cards remaining in the deck is below the CUT_CARD amount. If it is, the endGameMessage method is called, the end game message is displayed and the inner loop is broken. The inner loop being broken begins another iteration of the outer while loop, but in this case the outer while loop is determined to be false and the program is terminated. If the amount of cards remaining in the deck is greater than the CUT_CARD amount, the inner loop is still broken but the inner loop reiterates and begins by clearing each players hand and dealing a new hand. This explanation will remain the same for the next three methods.

If the checkStop variable assigned to the blackjackCheck method true the program continues by calling the playersDecision method. This method contains the logic related to whether the player can decide to hit or stand. The local variables int userInput and boolean playerStillHitting are declared, assigned and initialized. playerStillHitting is used in a while loop to allow the player to continue hitting if true or stand if false. This loop begins with reading of the users input. If the user inputs 1 they have chosen to stand and the loop inside the method is broken. This portion of the loop does not return anything because the checkStop variable in the playGame method is already true. If the player chooses 2 the player is dealt another card face up and that card is added to their hand and displayed. If that card causes the player to go over 21, the isBust method is called ending the hand, showing the dealers hand, breaking the loop and returning the isGameContinuing boolean as false. If this card does not cause the player to bust, the loop iterates again asking if they would like to stand or hit and the cycle is repeated. If the user inputs a number that is invalid an error message will appear asking them to try again. If the boolean isGameContinuing is returned as false, the logic mentioned above in the blackjackCheck method section is enacted in the same way.

If the checkStop variable assigned to the playersDecision method is true the program continues by calling the dealerMechanic method. This method contains the logic for how the dealer plays the game. A boolean is created for the same type of while loop used in the playersDecision method. The dealers hand is shown and the value of that hand is checked. The while loop is entered and if the dealers hand is above 17 and below 21 the loop is broken and the dealer stands. Otherwise, the dealer automatically draws a card, adds it to their hand, displays it, and their hands value is checked. If that card causes the dealer to bust, a winning message is displayed to the user, the methods loop is broken, and the isGameContinuing boolean is returned as false. This eventually breaking the playGame methods inner while loop. If the drawn card does not cause the dealer to bust, cards are drawn until either the dealer busts or a value is reached between and including the range of 17 and 21. If the boolean isGameContinuing is returned as false, the logic mentioned above in the blackjackCheck method section is enacted in the same way.

Finally, and if the conditions of the current hand permit, the comparing hands method is called. In this method, the values of the player's hand and dealer's hand are compared. A winner is chosen based on who has the highest value and a winning message is displayed depending on who has won. If the value of the hands is the same, the message "this hand is a push" is displayed. The boolean isGameContinuing will always be returned as false from this method as it will always cause the end of a hand. When the boolean isGameContinuing is returned as false, the logic mentioned above in the blackjackCheck method section is enacted in the same way aside from this time at least one of the loops will certanly be broken. 


# Technologies used
Java and Eclipse.
# Lessons Learned

The information that I learned from the jets project from last week was really solidified by this weeks Blackjack project. Seeing how cards are built and put into a deck, and then interacted with differently by the player and the dealer was greatly beneficial to my learning process. Also seeing how I could make it so the dealer was an extension of the player but could have its own private deck field that could not be interacted with solidified the concept of encapsulation.

The concept of Polymorphism also became much more understandable for me with this project specifically when dealing with the extension classes. Seeing how the dealer could use the player's protected BlackjackHand, and how the BlackjackHand class could use the methods from the abstract hand class was how this idea was reinforced. Overriding was also reinforced through the BlackjackPlayer and BlackjackDealer classes. 

I also learned quite a bit about using methods and objects for abstraction. The idea of how the application portion of the program should only show the user what is needed to run the program but not exactly how it is run was something that I had trouble understanding while working in class. However, this project and the NBA draft project we did during the week helped reinforce this idea greatly. 

Finally, I learned quite a bit about method interaction within a single class and while loops through the blackjack application. The nested while loop that I used was one that took quite a bit of effort to get to work properly. There may have been another way to do it, but I am pleased with how the program functions with the implementation I chose. However, I am not as pleased with lines 40 to 66 in the application. At first I attempted to have all of the conditions placed within one if and one else if statement using the || (or) operator. However, I was running into the problem that the program needs to check for the conditions after each time a method is called. Otherwise, there was fall through causing such things as the loop not to break if a blackjack hand was found on the initial deal. This was the solution I came up with to fix this problem, but it just does not look very DRY to me. I also tried to fix this problem by placing the entirety of lines 40 to 66 in a method of its own, but that was not allowed because the break statements needed to be placed in the same method as the while loop they were breaking. Overall though, I am very pleased with how this project turned out. 

